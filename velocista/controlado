#include <Arduino.h>
#include "BluetoothSerial.h"
#include <math.h>
BluetoothSerial SerialBT;

// ==== Pines ====
#define PWMA 21
#define AIN2 19
#define AIN1 18
#define STBY 5
#define BIN1 17
#define BIN2 16
#define PWMB 4

#define S1 35
#define S2 32
#define S3 33
#define S4 25
#define S5 26
#define S6 27
#define S7 14
#define S8 12

// Canales PWM
#define CH_A 0
#define CH_B 1

float S[8];
float pos[8] = {-30, -20, -10, -5, 5, 10, 20, 30}; 

// ==== Timers ====
hw_timer_t * timer0 = NULL;   

volatile bool flag_sample = false;  
volatile float position = 0,diffPWM = 0; 
volatile bool toggle=true;

int pwmBase =1800;
int pwmBaseMin=1600, pwmBaseMax=2400;
float lastError = 0; 
float lastDiffPWM = 0;
float lastUk = 0,lastUk2=0;

const float 
q0=115.8564 , q1=-70.1983 , s0=-0.0979         ,    // PD CON FILTRO 
K=54.9747 , alpha_lgr=0.7266 , beta=0.4365    ,    // COMPENSADOR
K_db= 0.0188, m1=0.6037 , a1=0.3963,alpha=0.2788    ;

void IRAM_ATTR onTimer0() {
  flag_sample = true;
}

void setup() {
  SerialBT.begin("velocista"); 

  // Pines

  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(STBY, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(S1, INPUT);
  pinMode(S2, INPUT);
  pinMode(S3, INPUT);
  pinMode(S4, INPUT);
  pinMode(S5, INPUT);
  pinMode(S6, INPUT);
  pinMode(S7, INPUT);
  pinMode(S8, INPUT);

  // PWM
  ledcSetup(CH_A, 1000, 12);
  ledcSetup(CH_B, 1000, 12);
  ledcAttachPin(PWMA, CH_A);  
  ledcAttachPin(PWMB, CH_B);

  timer0 = timerBegin(0, 80, true);
  timerAttachInterrupt(timer0, &onTimer0, true);
  timerAlarmWrite(timer0, 5000, true);
  timerAlarmEnable(timer0);

  // Habilitar driver
  ledcWrite(CH_A, 0);
  ledcWrite(CH_B, 0);
  digitalWrite(STBY, HIGH);
}

void loop() {
  // Si se activó la bandera → leer sensores
   if (flag_sample) {
     flag_sample = false; // limpiar bandera
     float cam=3.3/4096.0; 
    // Leer sensores
    S[0] = analogRead(S1)*cam; S[1] = analogRead(S2)*cam;
    S[2] = analogRead(S3)*cam; S[3] = analogRead(S4)*cam;
    S[4] = analogRead(S5)*cam; S[5] = analogRead(S6)*cam;
    S[6] = analogRead(S7)*cam; S[7] = analogRead(S8)*cam;

    // Calcular posición
    float numerator = 0;
    float denominator = 0;
    for (int i = 0; i < 8; i++) {
      numerator   += (float)S[i] * pos[i];
      denominator += (float)S[i];
    }

    if (denominator != 0) {
      position = numerator / denominator;
    } else {
      position = 0;
    }

    float angulo= (float)((2.48442*position) + 0.01062);

    
    float error = 0 - angulo;  // referencia = 0

   //pwmBase = pwmBaseMin + (pwmBaseMax - pwmBaseMin) * exp(-abs(error)*1.6);

    // PD CON FILTRO
    float Uk = q0*error + q1*lastError + s0*lastUk;
    
    // COMPENSADOR
    //float Uk= K*error-K*alpha_lgr*lastError+beta*lastUk;

    // DEAD BEAT
    //float Uk = (m1/K_db) *error - (m1/K_db)*alpha*lastError - a1*lastUk ;

    lastError = error;
    lastUk=Uk;

    diffPWM = (Uk / 100.0) * 4095;


    int pwmRight, pwmLeft;

    pwmRight = pwmBase-diffPWM/2;
    pwmLeft  = pwmBase+diffPWM/2;


    pwmRight = constrain(pwmRight, 0, 4095);
    pwmLeft  = constrain(pwmLeft, 0, 4095);


    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);

    ledcWrite(CH_A, pwmRight);
    ledcWrite(CH_B, pwmLeft);

    // Debug
     SerialBT.print(error);
     SerialBT.print("  ,  ");
    SerialBT.println(Uk);

  }
}
